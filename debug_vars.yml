---
# DEBUG VARIABLES
#
# This is a simple, short, standalone and stupid playbook to track undefined
# user-defined variables declared in `group_vars` and `host_vars` directories
# (beside the playbook as well as within inventory). Wait. What does it mean,
# exactly: undefined user-defined variables ? For example:
#
#---
#bar: "foo"
#foo: "{{ bar }}"
#
# ==> "foo": "foo"
#
#---
#foo: "{{ bar }}"
#
# ==> "foo": "VARIABLE IS NOT DEFINED!"                       (not verbose)
# ==> "foo": "VARIABLE IS NOT DEFINED!: 'bar' is undefined"   (verbose)
#
# Here, `foo` is an user-defined variable (not an ansible reserved variable,
# between others). If `bar` is defined, then `foo` is. If `bar` is not defined,
# then `foo` is not too. But `foo` will cause an error, not `bar`. Try with
# `debug_vars__remote_facts` set to yes and no, and:
#
#---
#foo: "{{ ansible_fqdn }}"
#
#
# Without customization, this playbook will fail in almost all cases, i.e. it
# will report errors about undefined variables.  If it is not the case, you
# should first ensure that clear passwords are not hardcoded in your ansible's
# git repository !
#
# Variables that control the behavior of this playbook:
#
# | NAME                     | SHORTCUT     | TYPE   | DEFAULT           |
# | ------------------------ | ------------ | ------ | ----------------- |
# | debug_vars__remote_facts | remote_facts | bool   | False             |
# | debug_vars__regex_filter | regex_filter | regex  | : (match nothing) |
# | debug_vars__assume_error | assume_error | int    | 0                 |
# | debug_vars__check_vars   | check_vars   | list,  | []                |
# |                          |              | string |                   |
#
# * debug_vars__remote_facts
#   When `True`, facts are gathered on the remote host, so variables whose the
#   values depend on `{{ ansible_fqdn }}` or any other fact are defined. When
#   `False`, there is no connection to the remote host at all, so variables
#   consistency can be checked apart (no need of credentials to login to the
#   hosts, even no need of the hosts themselves).
#
# * debug_vars__regex_filter
#   Because of not gathering facts, or because of vaulted values, or because
#   they are set by a specific role, or for whatever reason you want, some
#   variables may be legitimally undefined when running this playbook. For
#   example, with passwords vaulted and retrieved with an `include_vars`:
#   debug_vars__regex_filter: '_password$'
#   And yes, if you can't catch all of them in a simple regex, maybe it's time
#   to think to refactor them.
#
# * debug_vars__assume_error
#   A kind of quick start for the impatient. Instead of ignoring errors
#   globally, and if a regex is too hard to write or maintain, assume a given
#   number of errors. For example, assume 2 undefined variables. Unlike the
#   regex_filter results, assumed errors are reported in the last task.
#
# * debug_vars__check_vars
#   A specific variable, or a specific list of variables. When defined, it
#   overrides the dynamic query of all the variables applying to the host,
#   and only the provided variable names are evaluated. This can be used to
#   compare values of a single variable on many hosts.
#   The "list" can be either a YAML list, or any stringlist with commas and/or
#   spaces as field separators. We don't want to worry further about Jenkins
#   users inputs, we just accept versatile input formats. This is a valid
#   input: 'foo, bar baz ,, ,  foobaz foo,foobar, '; that will be converted into
#   the YAML list: [ "bar", "baz", "foo", "foobar", "foobaz" ] (sorted and
#   deduplicated).
#
#
# Usage:
# - set debug_vars__* variables in group_vars/
# - use the shortcuts as extra-vars in commandline
#
# Example:
# ansible-playbook debug_vars.yml -e remote_facts=yes -e regex_filter='_password$'


- name: DEBUG VARIABLES
  hosts: all
  gather_facts: "{{ remote_facts|bool if remote_facts is defined else
                    debug_vars__remote_facts|default(False)|bool }}"

  vars:
    oh_my_bad: '^VARIABLE IS NOT DEFINED!'
    check_vars: "{{ debug_vars__check_vars|default([]) }}"
    regex_filter: "{{ debug_vars__regex_filter|default(':') }}"
    assume_error: "{{ debug_vars__assume_error|default(0) }}"

    varfiles_all:
      - "group_vars/all"
      - "group_vars/all.yml"
      - "{{ inventory_dir }}/group_vars/all"
      - "{{ inventory_dir }}/group_vars/all.yml"
    varfiles_groups: |
      [
        {% for g in group_names %}
          "group_vars/{{ g }}",
          "group_vars/{{ g }}.yml",
          "{{ inventory_dir }}/group_vars/{{ g }}",
          "{{ inventory_dir }}/group_vars/{{ g }}.yml"
          {{ '' if loop.last else ',' }}
        {% endfor %}
      ]
    varfiles_host:
      - "host_vars/{{ inventory_hostname }}"
      - "host_vars/{{ inventory_hostname }}.yml"
      - "{{ inventory_dir }}/host_vars/{{ inventory_hostname }}"
      - "{{ inventory_dir }}/host_vars/{{ inventory_hostname }}.yml"

  tasks:
    # In all cases, some files or directories don't exist, and grep will fail
    # (exit code 2). Piping its output to sort allows the entire command to
    # never fail.  By design, elements of the list aren't deduplicated at this
    # step, so it is possible to see how many times a variable is declared,
    # i.e. how much the repo is simple, clear and easy to understand and to
    # maintain, or is a gaz factory.
    - name: get list of variables
      shell: >
        grep -Ehors '^[_a-zA-Z0-9]+' {{ ( varfiles_all + varfiles_groups + varfiles_host ) | join( ' ' ) }} |
        sort
      delegate_to: localhost
      connection: local
      register: result
      changed_when: false

    - name: set list of variables
      set_fact:
        # We accept all relevant input formats to get a final yaml list, sorted:
        # YAML list, single word, comma-space-separated list of words. Example:
        #     foo, bar,foobar baz   foobaz foo, ,,bar
        # will be converted to:
        #     [ "bar", "baz", "foo", "boobar", "foobaz" ]
        # It uses a pythonic split() method, as there is no such filter in jinja2
        variables: |
          {%
            if check_vars in [[],'']
              %}{{ result.stdout_lines | unique }}{%
            elif check_vars|type_debug == 'list'
              %}{{ check_vars | sort | unique }}{%
            elif ',' in check_vars|string or ' ' in check_vars|string
              %}{{ (check_vars|regex_replace( ' ', ',' )).split( ',' ) | difference(['']) | sort | unique }}{%
            else %}{{ [check_vars] | flatten | sort | unique }}{%
            endif
          %}


    - name: display list of variables
      debug:
        var: variables


    # This block is to trigger a handled error when:
    #
    # - a lot of variables are declared more than once, that may happen because
    #   of a lack of factorization in their valorization, or typically when a
    #   host has been mistakenly put in a group. For example if host `foobar`
    #   is member of `roma` group of webservers, and has been forgotten in
    #   another group of webservers, say `goteborg`. Deployment on `foobar`
    #   may as well never fail, as long as all variables set for `goteborg`
    #   are set for `roma` too, and as long as `roma` has precedence over
    #   `goteborg`, and as long as nothing evolves. Do you feel the ghost
    #   behind the door ?
    #
    # - a same variable is declared more than twice, that means it is difficult
    #   to follow it through the directory trees, and easy to forget the right
    #   place to set it for good. That may happen when:
    #   * the variable is set in group_vars/all, overridden for a group, then
    #     overridden for the host. It may be the right way, but you should ask
    #     if it is possible to get better factorization of the value, that may
    #     lead to remove one or more declarations.
    #   * the variable is errouneously set for a group that should not hold it,
    #     or the host is member of a group by mistake, or because of a mess in
    #     multi-instanciated services variables, or whatever you want, but that
    #     is NOGOOAALL (NOt GOOd At ALL), aka « no goal ».
    #
    - name: catch overridden variables
      block:
        - name: catch overridden variables (fail if too much)
          debug:
            var: duplicates
          # Fail if more than 10% of variables are overridden
          failed_when: result.stdout_lines|unique|length / duplicates|list|length < 10

        - name: fail if variables are overridden twice and more
          debug:
            var: multicates
          when: multicates != {}
          failed_when: true

      rescue:
        - name: "OVERRIDDEN VARIABLES"
          debug:
            msg: "it's time to do things simple and burn the gaz factory"

      when: duplicates != {}
      vars:
        # It uses a pythonic count() method, as there is no such filter in jinja2
        duplicates: |
          {
            {% for dup in variables if result.stdout_lines.count(dup) > 1 %}
            "{{ dup }}": "{{ result.stdout_lines.count(dup) }}"{{ '' if loop.last else ',' }}
            {% endfor %}
          }
        multicates: |
          {
            {% for dup in variables if result.stdout_lines.count(dup) > 2 %}
            "{{ dup }}": "{{ result.stdout_lines.count(dup) }}"{{ '' if loop.last else ',' }}
            {% endfor %}
          }


    # This is the primary purpose:
    - name: catch undefined variables
      block:
        - name: evaluate variables (fail if undefined and not filtered)
          debug:
            var: "{{ item }}"
          loop: "{{ variables }}"
          register: debug
          failed_when:
            - debug[item]|string | regex_search(oh_my_bad)
            - not item | regex_search(regex_filter)

        - name: SUCCESS
          debug:
            msg: "all variables ({{ variables | length }}) are defined{{
              '' if regex_filter == ':' else ' - or filtered by this regex: `%s`' % regex_filter }}"

      rescue:
        - name: "UNDEFINED VARIABLE(S) [/{{ variables | length }}]"
          debug:
            var: errors
          vars:
            digest: |
              [
                {% for res in debug.results %}{% for key in res %}
                {% if res[key]|string | regex_search(oh_my_bad) and not key|regex_search(regex_filter) %}
                "{{ key }}"{% else %}""{% endif %}{{ '' if loop.last else ',' }}
                {% endfor %}{{ '' if loop.last else ',' }}{% endfor %}
              ]
            errors: "{{ digest | difference(['']) }}"
          failed_when: errors|length > assume_error|int

